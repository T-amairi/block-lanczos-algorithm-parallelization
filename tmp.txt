#include <sys/resource.h>

void setStackLimit()
{
	const rlim_t kStackSize = 1048576 * 1000;
    struct rlimit rl;
    int result;

    result = getrlimit(RLIMIT_STACK, &rl);
    if (result == 0)
    {
        if (rl.rlim_cur < kStackSize)
        {
            rl.rlim_cur = kStackSize;
            result = setrlimit(RLIMIT_STACK, &rl);
            if (result != 0)
            {
                fprintf(stderr, "setrlimit returned result = %d\n", result);
            }
        }
    }
}

bool checkpoints = false;

/*************************** checkpoint functions ************************/

bool isElapsed(double time_in_sec, struct timeval t)
{
	return (t.tv_sec + t.tv_usec / 1e6) >= time_in_sec;
}

//to finish
/*
void load_vector_block(char const * filename, int nrows, int ncols, u32 * v)
{
	FILE * f;
    char * line = NULL;
    size_t len = 0;

    f = fopen(filename, "r");

    if(f == NULL)
	{
		printf("Cannot find the vector block to load\n");
        MPI_Abort(MPI_COMM_WORLD,MPI_ERR_IO);
	}

	int i = 0;

    while(getline(&line,&len,f) != -1)
	{
		if(i <= 1)
		{
			continue;
		}

		else if(i == 2)
		{
			char r[snprintf(NULL, 0,"%d",nrows) + 1];
			char c[snprintf(NULL, 0,"%d",ncols) + 1];

			sprintf(r,"%d",nrows);
			sprintf(c,"%d",ncols);



			
		}

		else
		{
			v[i - 3] = atoi(line);
		}

		i++;
    }

	if(line) free(line);
    fclose(f);
} */

//process 0 prepares the next iteration
if(myGridRank == 0)
{
	/* the next value of v is in tmp ; copy */
	for (long i = 0; i < block_size; i++)
		v[i] = tmp[i];

/*
	if(checkpoints && isElapsed(60,t))
	{
		save_vector_block("checkpoint.mtx", right_kernel ? M->ncols : M->nrows, n, v);
		gettimeofday(&t, NULL);
	}*/

	verbosity();
}

